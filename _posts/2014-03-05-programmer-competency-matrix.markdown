---
layout: post
title:  "程序员能力成熟度矩阵"
date:   2014-03-05 12:06:41
categories: developer career
---

Programmer Competency Matrix 程序员能力矩阵 http://sijinjoseph.com/programmer-competency-matrix/


> 注意每一级的知识是加成的；等级*n*意味着也掌握了*n*以下所有级别的知识


## Computer Science 计算机科学

<table>
  <thead>
    <tr>
      <th>
      </th>
      
      <th>
        2n(Level 0)
      </th>
      
      <th>
        n2(Level 1)
      </th>
      
      <th>
        n (Level 2)
      </th>
      
      <th>
        log(n) (Level 3)
      </th>
      
      <th>
        Comment
      </th>
    </tr>
  </thead>
  
  <tbody>
    <tr>
      <td>
        data structures
      </td>
      
      <td>
        Doesn’t know the difference between Array and LinkedList
      </td>
      
      <td>
        Able to explain and use Arrays, LinkedLists, Dictionaries etc in practical programming tasks
      </td>
      
      <td>
        Knows space and time tradeoffs of the basic data structures, Arrays vs LinkedLists, Able to explain how hashtables can be implemented and can handle collisions, Priority queues and ways to implement them etc.
      </td>
      
      <td>
        Knowledge of advanced data structures like B-trees, binomial and fibonacci heaps, AVL/Red Black trees, Splay Trees, Skip Lists, tries etc.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        数据结构
      </td>
      
      <td>
        不了解链表和数组的区别
      </td>
      
      <td>
        有能力解释和在开发中应用链表，数据，字典
      </td>
      
      <td>
        知道基本数据结构的时间和空间损耗。 能解释和实现哈希表如何处理冲突。 能实现优先队列。
      </td>
      
      <td>
        了解复杂数据结构 B-trees, binomial and fibonacci heaps, AVL/Red Black trees, Splay Trees, Skip Lists, tries etc.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        algorithms
      </td>
      
      <td>
        Unable to find the average of numbers in an array (It’s hard to believe but I’ve interviewed such candidates)
      </td>
      
      <td>
        Basic sorting, searching and data structure traversal and retrieval algorithms
      </td>
      
      <td>
        Tree, Graph, simple greedy and divide and conquer algorithms, is able to understand the relevance of the levels of this matrix.
      </td>
      
      <td>
        Able to recognize and code dynamic programming solutions, good knowledge of graph algorithms, good knowledge of numerical computation algorithms, able to identify NP problems etc.
      </td>
      
      <td>
        Working with someone who has a good topcoder ranking would be an unbelievable piece of luck!
      </td>
    </tr>
    
    <tr>
      <td>
        算法
      </td>
      
      <td>
        无法计算数组的平均数
      </td>
      
      <td>
        基本的排序，搜索，遍历和存取算法
      </td>
      
      <td>
        树，图，简单贪婪和分治算法，理解矩阵维度
      </td>
      
      <td>
        能识别和实现动态规划算法，数值计算，定位NP问题
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        systems programming
      </td>
      
      <td>
        Doesn’t know what a compiler, linker or interpreter is
      </td>
      
      <td>
        Basic understanding of compilers, linker and interpreters. Understands what assembly code is and how things work at the hardware level. Some knowledge of virtual memory and paging.
      </td>
      
      <td>
        Understands kernel mode vs. user mode, multi-threading, synchronization primitives and how they’re implemented, able to read assembly code. Understands how networks work, understanding of network protocols and socket level programming.
      </td>
      
      <td>
        Understands the entire programming stack, hardware (CPU + Memory + Cache + Interrupts + microcode), binary code, assembly, static and dynamic linking, compilation, interpretation, JIT compilation, garbage collection, heap, stack, memory addressing…
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        编程系统
      </td>
      
      <td>
        不知道什么是编译器，连接器和解释器
      </td>
      
      <td>
        对编译器，连接器和解释器有基本概念。明白谁汇编代码谁和硬件交互。对虚拟内存和分页的一些认识。
      </td>
      
      <td>
        明白内核模式与用户模式，多线程，同步和如何实现。能读懂汇编代码，明白网络工作原理，协议层和接口层编程。
      </td>
      
      <td>
        理解程序全栈知识：硬件（CPU+内存+缓存+终端+微代码），二进制码，汇编，静态和动态链接，编译，解释，JIT编译，垃圾回收，堆，栈，内存寻址
      </td>
      
      <td>
      </td>
    </tr>
  </tbody>
</table>

## Software Engineering 软件工程

<table>
  <thead>
    <tr>
      <th>
      </th>
      
      <th>
        2n(Level 0)
      </th>
      
      <th>
        n2(Level 1)
      </th>
      
      <th>
        n (Level 2)
      </th>
      
      <th>
        log(n) (Level 3)
      </th>
      
      <th>
        Comments
      </th>
    </tr>
  </thead>
  
  <tbody>
    <tr>
      <td>
        source code version control
      </td>
      
      <td>
        Folder backups by date
      </td>
      
      <td>
        VSS and beginning CVS/SVN user
      </td>
      
      <td>
        Proficient in using CVS and SVN features. Knows how to branch and merge, use patches setup repository properties etc.
      </td>
      
      <td>
        Knowledge of distributed VCS systems. Has tried out Bzr/Mercurial/Darcs/Git
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        版本控制
      </td>
      
      <td>
        目录备份
      </td>
      
      <td>
        VSS和初级CVS/SVN用户
      </td>
      
      <td>
        熟悉高级CVS/SVN功能，知道如何分支和合并，使用补丁配置仓库属性等
      </td>
      
      <td>
        知道分布式VCS系统，使用GIT等
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        build automation
      </td>
      
      <td>
        Only knows how to build from IDE
      </td>
      
      <td>
        Knows how to build the system from the command line
      </td>
      
      <td>
        Can setup a script to build the basic system
      </td>
      
      <td>
        Can setup a script to build the system and also documentation, installers, generate release notes and tag the code in source control
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        构建自动化
      </td>
      
      <td>
        只知道如何从IDE构建
      </td>
      
      <td>
        知道如何从命令行构建
      </td>
      
      <td>
        能够设定脚本去构建基本系统
      </td>
      
      <td>
        能够设定脚本构建系统和文档，安装器，版本日志，在代码库中标记
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        automated testing
      </td>
      
      <td>
        Thinks that all testing is the job of the tester
      </td>
      
      <td>
        Has written automated unit tests and comes up with good unit test cases for the code that is being written
      </td>
      
      <td>
        Has written code in TDD manner
      </td>
      
      <td>
        Understands and is able to setup automated functional, load/performance and UI tests
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        自动测试
      </td>
      
      <td>
        认为所有测试都是测试人员的事情
      </td>
      
      <td>
        编写自动单元测试代码，能够写出不错的测试用例
      </td>
      
      <td>
        TDD测试驱动开发
      </td>
      
      <td>
        理解并能够设置自动构建功能，性能测试和UI测试
      </td>
      
      <td>
      </td>
    </tr>
  </tbody>
</table>

# Programming 编程

<table>
  <thead>
    <tr>
      <th>
      </th>
      
      <th>
        2n(Level 0)
      </th>
      
      <th>
        n2(Level 1)
      </th>
      
      <th>
        n (Level 2)
      </th>
      
      <th>
        log(n) (Level 3)
      </th>
      
      <th>
        Comments
      </th>
    </tr>
  </thead>
  
  <tbody>
    <tr>
      <td>
        problem decomposition
      </td>
      
      <td>
        Only straight line code with copy paste for reuse
      </td>
      
      <td>
        Able to break up problem into multiple functions
      </td>
      
      <td>
        Able to come up with reusable functions/objects that solve the overall problem
      </td>
      
      <td>
        Use of appropriate data structures and algorithms and comes up with generic/object-oriented code that encapsulate aspects of the problem that are subject to change.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        问题分析
      </td>
      
      <td>
        只有直接逻辑和CV打法
      </td>
      
      <td>
        能够分析问题为多个功能
      </td>
      
      <td>
        能够使用可服用的代码或对象解决系列问题
      </td>
      
      <td>
        使用合适的数据结构和算法，封装可应用于变化主题，针对问题切面的，通用/面向对象的代码
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        systems decomposition
      </td>
      
      <td>
        Not able to think above the level of a single file/class
      </td>
      
      <td>
        Able to break up problem space and design solution as long as it is within the same platform/technology
      </td>
      
      <td>
        Able to design systems that span multiple technologies/platforms.
      </td>
      
      <td>
        Able to visualize and design complex systems with multiple product lines and integrations with external systems. Also should be able to design operations support systems like monitoring, reporting, fail overs etc.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        系统分析
      </td>
      
      <td>
        没有能力考虑多于单个类或文件
      </td>
      
      <td>
        有能力分析问题空间，在面对同样平台/技术时，设计解决方案
      </td>
      
      <td>
        有能力设计跨平台系统
      </td>
      
      <td>
        有能力设计和可视化设计多产线，与外部交互的复杂系统。能够设计运营支撑系统，如监控，报表，错误恢复等
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        communication
      </td>
      
      <td>
        Cannot express thoughts/ideas to peers. Poor spelling and grammar.
      </td>
      
      <td>
        Peers can understand what is being said. Good spelling and grammar.
      </td>
      
      <td>
        Is able to effectively communicate with peers
      </td>
      
      <td>
        Able to understand and communicate thoughts/design/ideas/specs in a unambiguous manner and adjusts communication as per the context
      </td>
      
      <td>
        This is an often under rated but very critical criteria for judging a programmer. With the increase in outsourcing of programming tasks to places where English is not the native tongue this issue has become more prominent. I know of several projects that failed because the programmers could not understand what the intent of the communication was.
      </td>
    </tr>
    
    <tr>
      <td>
        沟通
      </td>
      
      <td>
        无法向同伴传达想法和思路。欠佳的拼写和语法。
      </td>
      
      <td>
        同伴可理解。良好的拼写和语法能力。
      </td>
      
      <td>
        能够与同伴高效沟通。
      </td>
      
      <td>
        能够明确的理解和交流思路\设计\想法\规格说明。多场景沟通。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        code organization within a file
      </td>
      
      <td>
        no evidence of organization within a file
      </td>
      
      <td>
        Methods are grouped logically or by accessibility
      </td>
      
      <td>
        Code is grouped into regions and well commented with references to other source files
      </td>
      
      <td>
        File has license header, summary, well commented, consistent white space usage. The file should look beautiful.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        单文件代码组织
      </td>
      
      <td>
        没有在文件内组织代码的迹象。
      </td>
      
      <td>
        根据逻辑或访问权限分组方法
      </td>
      
      <td>
        分组代码区域，有适当注释指向其他源文件。
      </td>
      
      <td>
        文件有授权协议，概述，良好的注释，一致的空白符使用。看起来优美。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        code organization across files
      </td>
      
      <td>
        No thought given to organizing code across files
      </td>
      
      <td>
        Related files are grouped into a folder
      </td>
      
      <td>
        Each physical file has a unique purpose, for e.g. one class definition, one feature implementation etc.
      </td>
      
      <td>
        Code organization at a physical level closely matches design and looking at file names and folder distribution provides insights into design
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        文件间代码组织
      </td>
      
      <td>
        没有考虑过文件间代码组织
      </td>
      
      <td>
        相关文件在目录中归类
      </td>
      
      <td>
        每一个物理文件有单一目的。
      </td>
      
      <td>
        代码的物理与设计层级匹配，通过文件名称和目录结构可以东西设计意图。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        source tree organization
      </td>
      
      <td>
        Everything in one folder
      </td>
      
      <td>
        Basic separation of code into logical folders.
      </td>
      
      <td>
        No circular dependencies, binaries, libs, docs, builds, third-party code all organized into appropriate folders
      </td>
      
      <td>
        Physical layout of source tree matches logical hierarchy and organization. The directory names and organization provide insights into the design of the system.
      </td>
      
      <td>
        The difference between this and the previous item is in the scale of organization, source tree organization relates to the entire set of artifacts that define the system.
      </td>
    </tr>
    
    <tr>
      <td>
        源码树组织
      </td>
      
      <td>
        所有文件都在同一目录。
      </td>
      
      <td>
        基本逻辑分类。
      </td>
      
      <td>
        没有循环依赖。二进制码，库文件，文档，构建，第三方代码都归类到适当的目录。
      </td>
      
      <td>
        源码物理布局和逻辑层级匹配。目录名称和组织可洞悉系统设计。
      </td>
      
      <td>
        这一项和前一项的不同主要在范围。
      </td>
    </tr>
    
    <tr>
      <td>
        code readability
      </td>
      
      <td>
        Mono-syllable names
      </td>
      
      <td>
        Good names for files, variables classes, methods etc.
      </td>
      
      <td>
        No long functions, comments explaining unusual code, bug fixes, code assumptions
      </td>
      
      <td>
        Code assumptions are verified using asserts, code flows naturally – no deep nesting of conditionals or methods
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        代码可读性
      </td>
      
      <td>
        简单名称
      </td>
      
      <td>
        文件变量类方法等有好的命名
      </td>
      
      <td>
        没有长方法，注释解释了非常见代码，错误修正，代码假设。
      </td>
      
      <td>
        代码假设通过asserts验证，代码流自然——没有深层条件或方法嵌套
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        defensive coding
      </td>
      
      <td>
        Doesn’t understand the concept
      </td>
      
      <td>
        Checks all arguments and asserts critical assumptions in code
      </td>
      
      <td>
        Makes sure to check return values and check for exceptions around code that can fail.
      </td>
      
      <td>
        Has his own library to help with defensive coding, writes unit tests that simulate faults
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        防御性代码
      </td>
      
      <td>
        不理解这个概念
      </td>
      
      <td>
        代码中检查所有参数和关键性假设。
      </td>
      
      <td>
        确信返回值校验并检查可能的异常。
      </td>
      
      <td>
        有自己库协助防御性编程，编写单元测试模拟缺陷。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        error handling
      </td>
      
      <td>
        Only codes the happy case
      </td>
      
      <td>
        Basic error handling around code that can throw exceptions/generate errors
      </td>
      
      <td>
        Ensures that error/exceptions leave program in good state, resources, connections and memory is all cleaned up properly
      </td>
      
      <td>
        Codes to detect possible exception before, maintain consistent exception handling strategy in all layers of code, come up with guidelines on exception handling for entire system.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        错误处理
      </td>
      
      <td>
        只编码正常情况。
      </td>
      
      <td>
        基本的错误处理和异常捕捉。
      </td>
      
      <td>
        确信错误和异常仍能保障程序在正常状态。资源，连接和内存都被正常清理。
      </td>
      
      <td>
        检测之前异常的代码。在所有代码层级维护一致性的异常处理策略。整个系统有异常处理指引。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        IDE
      </td>
      
      <td>
        Mostly uses IDE for text editing
      </td>
      
      <td>
        Knows their way around the interface, able to effectively use the IDE using menus.
      </td>
      
      <td>
        Knows keyboard shortcuts for most used operations.
      </td>
      
      <td>
        Has written custom macros
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        IDE
      </td>
      
      <td>
        大多数时候只使用IDE进行编辑文本。
      </td>
      
      <td>
        知道界面使用方法，能够有效使用IDE菜单。
      </td>
      
      <td>
        知道大多数常用操作的快捷键。
      </td>
      
      <td>
        能够编写自定义宏。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        API
      </td>
      
      <td>
        Needs to look up the documentation frequently
      </td>
      
      <td>
        Has the most frequently used APIs in memory
      </td>
      
      <td>
        Vast and In-depth knowledge of the API
      </td>
      
      <td>
        Has written libraries that sit on top of the API to simplify frequently used tasks and to fill in gaps in the API
      </td>
      
      <td>
        E.g. of API can be Java library, .net framework or the custom API for the application
      </td>
    </tr>
    
    <tr>
      <td>
        API
      </td>
      
      <td>
        需要经常查看文档。
      </td>
      
      <td>
        记住大多数常用的API.
      </td>
      
      <td>
        对API广泛而深入的理解，自己在API编写针对常见任务的库。
      </td>
      
      <td>
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        frameworks
      </td>
      
      <td>
        Has not used any framework outside of the core platform
      </td>
      
      <td>
        Has heard about but not used the popular frameworks available for the platform.
      </td>
      
      <td>
        Has used more than one framework in a professional capacity and is well-versed with the idioms of the frameworks.
      </td>
      
      <td>
        Author of framework
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        框架
      </td>
      
      <td>
        在核心平台外没有用过任何框架。
      </td>
      
      <td>
        听过但是没有用过平台上的一些流行框架。
      </td>
      
      <td>
        使用过一个以上框架，专业能力能达到框架可能的理想境地。
      </td>
      
      <td>
        框架作者。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        requirements
      </td>
      
      <td>
        Takes the given requirements and codes to spec
      </td>
      
      <td>
        Come up with questions regarding missed cases in the spec
      </td>
      
      <td>
        Understand complete picture and come up with entire areas that need to be speced
      </td>
      
      <td>
        Able to suggest better alternatives and flows to given requirements based on experience
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        需求
      </td>
      
      <td>
        接受给定需求规范编写代码。
      </td>
      
      <td>
        处理规范缺失的需求问题。
      </td>
      
      <td>
        理解完整图像，解决全局规格说明。
      </td>
      
      <td>
        能够根据给定需求和经验建议更好的替代或流程。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        scripting
      </td>
      
      <td>
        No knowledge of scripting tools
      </td>
      
      <td>
        Batch files/shell scripts
      </td>
      
      <td>
        Perl/Python/Ruby/VBScript/Powershell
      </td>
      
      <td>
        Has written and published reusable code
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        脚本
      </td>
      
      <td>
        不了解脚本工具。
      </td>
      
      <td>
        批处理/shell
      </td>
      
      <td>
        Perl/Python/Ruby/VBScript/Powershell
      </td>
      
      <td>
        编写并发布过可复用代码
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        database
      </td>
      
      <td>
        Thinks that Excel is a database
      </td>
      
      <td>
        Knows basic database concepts, normalization, ACID, transactions and can write simple selects
      </td>
      
      <td>
        Able to design good and normalized database schemas keeping in mind the queries that’ll have to be run, proficient in use of views, stored procedures, triggers and user defined types. Knows difference between clustered and non-clustered indexes. Proficient in use of ORM tools.
      </td>
      
      <td>
        Can do basic database administration, performance optimization, index optimization, write advanced select queries, able to replace cursor usage with relational sql, understands how data is stored internally, understands how indexes are stored internally, understands how databases can be mirrored, replicated etc. Understands how the two phase commit works.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        数据库
      </td>
      
      <td>
        认为Excel是数据库
      </td>
      
      <td>
        知道基本的数据库概念，范式，ACID，事务。可以编写简单的selects
      </td>
      
      <td>
        能够设计良好规范的数据库Schema，注重可能运行的查询，娴熟应用视图，存储过程，触发器和用户定义类型。知道集群和非集群索引的区别。娴熟应用ORM工具。
      </td>
      
      <td>
        能够做基本的数据库管理，性能优化，索引优化，编写高级select查询，能够用关系SQL替换指针使用，理解数据内部存储，理解索引内部存储，理解数据库镜像，复制等。理解两步提交过程。
      </td>
      
      <td>
      </td>
    </tr>
  </tbody>
</table>

* * *

# Experience 经验

<table>
  <thead>
    <tr>
      <th>
      </th>
      
      <th>
        2n(Level 0)
      </th>
      
      <th>
        n2(Level 1)
      </th>
      
      <th>
        n (Level 2)
      </th>
      
      <th>
        log(n) (Level 3)
      </th>
      
      <th>
        Comments
      </th>
    </tr>
  </thead>
  
  <tbody>
    <tr>
      <td>
        platforms with professional experience
      </td>
      
      <td>
        1
      </td>
      
      <td>
        2-3
      </td>
      
      <td>
        4-5
      </td>
      
      <td>
        6+
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        平台经验
      </td>
      
      <td>
        1
      </td>
      
      <td>
        2-3
      </td>
      
      <td>
        4-5
      </td>
      
      <td>
        6+
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        years of professional experience
      </td>
      
      <td>
        1
      </td>
      
      <td>
        2-5
      </td>
      
      <td>
        6-9
      </td>
      
      <td>
        10+
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        工作经验
      </td>
      
      <td>
        1
      </td>
      
      <td>
        2-5
      </td>
      
      <td>
        6-9
      </td>
      
      <td>
        10+
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        domain knowledge
      </td>
      
      <td>
        No knowledge of the domain
      </td>
      
      <td>
        Has worked on at least one product in the domain.
      </td>
      
      <td>
        Has worked on multiple products in the same domain.
      </td>
      
      <td>
        Domain expert. Has designed and implemented several products/solutions in the domain. Well versed with standard terms, protocols used in the domain.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        领域知识
      </td>
      
      <td>
        没有领域知识
      </td>
      
      <td>
        在领域中至少一个产品有工作实绩。
      </td>
      
      <td>
        在同样领域有多个产品经验。
      </td>
      
      <td>
        领域专家。设计和实现了多个产品或解决方案。熟练掌握领域标准术语，协议。
      </td>
      
      <td>
      </td>
    </tr>
  </tbody>
</table>

* * *

# Knowledge 知识

<table>
  <thead>
    <tr>
      <th>
      </th>
      
      <th>
        2n(Level 0)
      </th>
      
      <th>
        n2(Level 1)
      </th>
      
      <th>
        n (Level 2)
      </th>
      
      <th>
        log(n) (Level 3)
      </th>
      
      <th>
        Comments
      </th>
    </tr>
  </thead>
  
  <tbody>
    <tr>
      <td>
        tool knowledge
      </td>
      
      <td>
        Limited to primary IDE (VS.Net, Eclipse etc.)
      </td>
      
      <td>
        Knows about some alternatives to popular and standard tools.
      </td>
      
      <td>
        Good knowledge of editors, debuggers, IDEs, open source alternatives etc. etc. For e.g. someone who knows most of the tools from Scott Hanselman’s power tools list. Has used ORM tools.
      </td>
      
      <td>
        Has actually written tools and scripts, added bonus if they’ve been published.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        工具知识
      </td>
      
      <td>
        局限于主流IDE(VS.net Eclipse etc.)
      </td>
      
      <td>
        知道一些流行和标准工具的替代品。
      </td>
      
      <td>
        很好的了解编辑器，调试工具，IDE，开源替代品等等。
      </td>
      
      <td>
        曾经写过工具和脚本，最好发布过。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        languages exposed to
      </td>
      
      <td>
        Imperative or Object Oriented
      </td>
      
      <td>
        Imperative, Object-Oriented and declarative (SQL), added bonus if they understand static vs dynamic typing, weak vs strong typing and static inferred types
      </td>
      
      <td>
        Functional, added bonus if they understand lazy evaluation, currying, continuations
      </td>
      
      <td>
        Concurrent (Erlang, Oz) and Logic (Prolog)
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        语言使用
      </td>
      
      <td>
        命令式或面向对象
      </td>
      
      <td>
        命令式，面向对象，声明式。如果理解静态类型和动态类型，弱类型和强类型及静态推断类型更佳
      </td>
      
      <td>
        函数式，如果理解惰性求值，加里化，后续传递。
      </td>
      
      <td>
        并发语言(Erlang, Oz) and 逻辑语言(Prolog)
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        codebase knowledge
      </td>
      
      <td>
        Has never looked at the codebase
      </td>
      
      <td>
        Basic knowledge of the code layout and how to build the system
      </td>
      
      <td>
        Good working knowledge of code base, has implemented several bug fixes and maybe some small features.
      </td>
      
      <td>
        Has implemented multiple big features in the codebase and can easily visualize the changes required for most features or bug fixes.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        开源社区（codebase,git）
      </td>
      
      <td>
        从来没听过
      </td>
      
      <td>
        基本的代码布局知道如何构建系统
      </td>
      
      <td>
        良好的相关知识，曾经实现过一些缺陷修复或者增添过一些功能。
      </td>
      
      <td>
        曾经实现了多个主要功能。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        knowledge of upcoming technologies
      </td>
      
      <td>
        Has not heard of the upcoming technologies
      </td>
      
      <td>
        Has heard of upcoming technologies in the field
      </td>
      
      <td>
        Has downloaded the alpha preview/CTP/beta and read some articles/manuals
      </td>
      
      <td>
        Has played with the previews and has actually built something with it and as a bonus shared that with everyone else
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        新技术知识
      </td>
      
      <td>
        从来没关注过新技术。
      </td>
      
      <td>
        听过说相关领域的新技术。
      </td>
      
      <td>
        下载体验过一些手册和预览版本。
      </td>
      
      <td>
        使用过预览版并且实际构建过一些东西。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        platform internals
      </td>
      
      <td>
        Zero knowledge of platform internals
      </td>
      
      <td>
        Has basic knowledge of how the platform works internally
      </td>
      
      <td>
        Deep knowledge of platform internals and can visualize how the platform takes the program and converts it into executable code.
      </td>
      
      <td>
        Has written tools to enhance or provide information on platform internals. For e.g. disassemblers, decompilers, debuggers etc.
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        平台内部
      </td>
      
      <td>
        对平台内部0认知
      </td>
      
      <td>
        有一些平台内部工作原理的基本认识。
      </td>
      
      <td>
        对内部的升入认识，可以图示平台如果将程序编程可执行代码。
      </td>
      
      <td>
        写过工具来呈现平台内部信息。如：反汇编，反编译，调试器等。
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        books
      </td>
      
      <td>
        Unleashed series, 21 days series, 24 hour series, dummies series…
      </td>
      
      <td>
        Code Complete, Don’t Make me Think, Mastering Regular Expressions
      </td>
      
      <td>
        Design Patterns, Peopleware, Programming Pearls, Algorithm Design Manual, Pragmatic Programmer, Mythical Man month
      </td>
      
      <td>
        Structure and Interpretation of Computer Programs, Concepts Techniques, Models of Computer Programming, Art of Computer Programming, Database systems , by C. J Date, Thinking Forth, Little Schemer
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        书籍
      </td>
      
      <td>
        快速入门之类
      </td>
      
      <td>
        代码大全，设计模式，概念技术，算法，人月神话等
      </td>
      
      <td>
        计算机程序艺术，数据库系统等
      </td>
      
      <td>
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        blogs
      </td>
      
      <td>
        Has heard of them but never got the time.
      </td>
      
      <td>
        Reads tech/programming/software engineering blogs and listens to podcasts regularly.
      </td>
      
      <td>
        Maintains a link blog with some collection of useful articles and tools that he/she has collected
      </td>
      
      <td>
        Maintains a blog in which personal insights and thoughts on programming are shared
      </td>
      
      <td>
      </td>
    </tr>
    
    <tr>
      <td>
        博客
      </td>
      
      <td>
        听说过从来没时间看
      </td>
      
      <td>
        经常阅读技术和工程博客
      </td>
      
      <td>
        维护一个收集类的博客
      </td>
      
      <td>
        维护一个个人见解和编程思路的博客
      </td>
      
      <td>
      </td>
    </tr>
  </tbody>
</table>


> Thanks to [John Haugeland][1] for a  
> reformatting of it that works much more nicely on the web.

 [1]: http://fullof.bs/